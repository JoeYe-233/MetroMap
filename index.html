<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åœ°é“å®æ—¶è¿è¡Œå›¾</title>
    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; overflow: hidden; background: #f5f5f5; }

        /* --- æ ¸å¿ƒæ§åˆ¶åŒºæ ·å¼ --- */
        #controls {
            position: fixed; bottom: 20px; left: 5%; width: 90%;
            background: rgba(255, 255, 255, 0.9); padding: 15px; border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); backdrop-filter: blur(5px);
            z-index: 100; display: flex; flex-direction: column; gap: 10px;
        }
        .status-bar { display: flex; justify-content: space-between; align-items: center; }
        .time-display { font-size: 1.2em; font-weight: bold; color: #333; font-variant-numeric: tabular-nums; }
        .mode-switch { font-size: 0.9em; color: #666; display: flex; align-items: center; gap: 5px; }

        /* ================= ä¿®æ”¹ï¼šè‡ªå®šä¹‰æ»‘å—æ ·å¼ (è§£å†³æ‰‹æŒ‡é®æŒ¡é—®é¢˜) ================= */
        .slider-wrapper {
            position: relative;
            width: 100%;
            height: 50px; /* æ•´ä¸ªè§¦æ§åŒºåŸŸé«˜åº¦ï¼Œè¶³å¤Ÿå¤§ä»¥ä¾¿æ‰‹æŒ‡æ“ä½œ */
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* è§†è§‰å…ƒç´ é ä¸Š */
            margin-top: 5px;
        }

        /* 1. è§†è§‰è½¨é“ (ç»†çº¿/çª„çŸ©å½¢) */
        .visual-track {
            position: absolute;
            top: 12px; /* è·ç¦»é¡¶éƒ¨çš„ä½ç½® */
            left: 0;
            width: 100%;
            height: 4px; /* çº¿æ¡åšåº¦ */
            /* æ¼‚äº®çš„æ¸å˜è‰²: æ·±è“(æ·±å¤œ)-é»„(æ—©)-ç»¿(å¹³å³°)-æ©™(æ™š)-çº¢(åœè¿)-æ·±ç° */
            /* æ ¹æ®éçº¿æ€§æ¯”ä¾‹è°ƒæ•´é¢œè‰²åˆ†å¸ƒï¼š
            0% - 20%: æ—©é«˜å³°å‰ (ç°/é»„) - å¯¹åº”è¾ƒçŸ­é•¿åº¦
            20% - 35%: ç™½å¤©å¹³å³° (ç»¿) - å¯¹åº”æçŸ­é•¿åº¦ (è™½ç„¶æ—¶é—´é•¿ï¼Œä½†è¢«å‹ç¼©äº†)
            35% - 90%: æ™šé—´æ”¶è½¦ (æ©™/çº¢) - ğŸš¨ å æ®äº† 55% çš„é•¿åº¦ï¼Œéå¸¸æ˜¾çœ¼ä¸”çµæ•
            90% - 100%: æ·±å¤œ (æ·±ç°)
            */
            background: linear-gradient(to right,
                #34495e 0%,
                #f1c40f 20%,
                #2ecc71 20%,
                #2ecc71 35%,
                #e67e22 35%,
                #c0392b 90%,
                #2c3e50 90%
            );
            border-radius: 2px;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€è¿‡å» */
            z-index: 1;
        }

        /* 2. è§†è§‰æŒ‡é’ˆ (æŒ‡ç¤ºå½“å‰ä½ç½®) */
        .visual-thumb {
            position: absolute;
            top: 0;
            left: 0%; /* JS åŠ¨æ€æ§åˆ¶è¿™é‡Œ */
            width: 2px; /* æŒ‡é’ˆé‚£æ ¹çº¿çš„å®½åº¦ */
            height: 28px; /* æŒ‡é’ˆé«˜åº¦ï¼Œç©¿è¿‡è½¨é“ */
            background: #e74c3c; /* çº¢è‰²æŒ‡é’ˆ */
            z-index: 2;
            transform: translateX(-50%); /* å±…ä¸­å¯¹é½ */
            pointer-events: none;
            /* transition: left 0.1s linear;  æ‹–åŠ¨æ—¶ä¸ºäº†è·Ÿæ‰‹ï¼Œå»ºè®®å…³æ‰ CSS è¿‡æ¸¡ï¼Œæˆ–è€…åªåœ¨ tick æ—¶å¼€å¯ */
        }

        /* ç»™æŒ‡é’ˆåŠ ä¸ªâ€œå¤´â€ï¼Œçœ‹èµ·æ¥æ›´åƒæŒ‡é’ˆ */
        .visual-thumb::after {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            width: 10px;
            height: 10px;
            background: #e74c3c;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        /* 3. å®é™…äº¤äº’çš„ Input (éšå½¢ã€å·¨å¤§) */
        input[type=range] {
            position: absolute;
            bottom: 0; /* æ”¾åœ¨åº•éƒ¨ï¼Œè®©ç”¨æˆ·æ‘¸ä¸‹é¢ */
            left: 0;
            width: 100%;
            height: 40px; /* è§¦æ§åŒºåŸŸé«˜åº¦ */
            opacity: 0; /* å®Œå…¨é€æ˜ï¼Œä¸å¯è§ */
            margin: 0;
            padding: 0;
            z-index: 3; /* åœ¨æœ€ä¸Šå±‚æ¥æ”¶ç‚¹å‡» */
            cursor: pointer;
        }

        /* --- åœ°å›¾å®¹å™¨ --- */
        #map-container {
            width: 100vw; height: 100vh; overflow: hidden; background: #f5f5f5; position: relative;
        }
        /* #map-container:active { cursor: grabbing; } */

        /* SVG æ ·å¼ */
        svg { width: 100%; height: 100%; display: block; touch-action: none; }

        /* è·¯å¾„è¿‡æ¸¡åŠ¨ç”» */
        path { transition: stroke 0.5s ease, opacity 0.5s ease, filter 0.5s ease; }
        rect { transition: fill 0.5s ease, stroke 0.5s ease, opacity 0.5s ease, filter 0.5s ease; }
        polygon { transition: fill 0.5s ease, stroke 0.5s ease, opacity 0.5s ease, filter 0.5s ease; }

        /* ================= æ ·å¼ä¿®æ­£ ================= */

        /* 1. é’ˆå¯¹çº¿è·¯ (æ‰€æœ‰ ID ä»¥ "seg_" å¼€å¤´çš„å…ƒç´ ) */
        [id^="seg_"].disabled {
            stroke: #dcdcdc !important;   /* çº¿æ¡å˜ç° */
            stroke-opacity: 0.3 !important;

            fill: none !important;        /* ğŸš¨ å…³é”®ï¼å¼ºåˆ¶ç¦æ­¢å¡«å……ï¼Œæ¶ˆé™¤å¥‡æ€ªçš„ä¸‰è§’åŒº */
        }

        /* 2. é’ˆå¯¹è½¦ç«™ (æ‰€æœ‰ ID ä»¥ "station_" å¼€å¤´çš„å…ƒç´ ) */
        [id^="station_"].disabled {
            fill: #dcdcdc !important;     /* å¡«å……å˜ç° */
            fill-opacity: 0.3 !important;

            stroke: #dcdcdc !important;      /*è½¦ç«™é€šå¸¸ä¸éœ€è¦æè¾¹ï¼Œæˆ–è€…ä¿æŒåŸæ ·*/
        }

        /* --- ä¿¡æ¯å¼¹çª—æ ·å¼ --- */
        #info-modal {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            max-height: 50vh; /* æœ€å¤šå ä¸€åŠå±å¹• */
            background: white;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
            z-index: 200; /* æ¯”æ§åˆ¶æ æ›´é«˜ */
            border-radius: 12px 12px 0 0;
            overflow-y: auto;
            transition: transform 0.3s ease;
            padding-bottom: 20px;
            box-sizing: border-box;
        }

        .modal-header {
            padding: 15px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            background: white;
        }

        .modal-header h3 { margin: 0; font-size: 1.1em; }

        .modal-body { padding: 15px; font-size: 0.9em; line-height: 1.6; }

        .info-block { margin-bottom: 15px; }
        .info-label { font-weight: bold; color: #666; display: block; margin-bottom: 4px; }
        .info-value { color: #333; }
        .dep-list { font-family: monospace; background: #f5f5f5; padding: 5px; border-radius: 4px; word-break: break-all;}
    </style>
</head>

<body>

    <div id="map-container">
        <div id="loading-tip" style="position:absolute; top: 40%; width: 100%; text-align: center; color: #666;">
            æ­£åœ¨åŠ è½½åœ°å›¾èµ„æº...
        </div>
    </div>

    <div id="controls">
        <div class="status-bar">
            <div class="time-display" id="clock">12:00</div>
            <label class="mode-switch">
                <input type="checkbox" id="live-toggle" checked> å®æ—¶æ¨¡å¼
            </label>
        </div>

        <div class="slider-wrapper">
            <div class="visual-track"></div>
            <div class="visual-thumb" id="custom-thumb"></div>

            <input type="range" id="time-slider" min="0" max="10000" value="0">
        </div>

        <div style="font-size: 12px; color: #999; text-align: center; margin-top: -10px; pointer-events: none;">
            æ‰‹æŒ‡åœ¨ä¸‹æ–¹ç©ºç™½å¤„æ‹–åŠ¨ï¼Œè§‚å¯Ÿä¸Šæ–¹çº¢çº¿ (06:00 - æ¬¡æ—¥02:00)
        </div>
    </div>

    <div id="info-modal" style="display: none;">
        <div class="modal-header">
            <h3 id="modal-title">ç«™ç‚¹åç§°</h3>
            <button onclick="closeModal()" style="padding: 5px 10px;">Ã—</button>
        </div>
        <div id="modal-content" class="modal-body"></div>
    </div>

    <script src="https://unpkg.com/panzoom@9.4.0/dist/panzoom.min.js"></script>
    <script>
        // ================= é…ç½®åŒºåŸŸ =================

        // ã€æ–°å¢ã€‘è½¦ç«™ç¼–å·ä¿®æ­£è¡¨
        // æ ¼å¼: "çº¿è·¯ç¼–å·_JSONä¸­çš„è½¦ç«™å·": "SVGä¸­çš„è½¦ç«™å·"
        const STATION_ID_FIX_MAP = {
            "330103_0112": "0330", // æ­¦æ—å¹¿åœº (3å·çº¿å´å±±å‰æ‘-æ˜Ÿæ¡¥, JSONåŸå·:0112)
            "330103_0113": "0331", // è¥¿æ¹–æ–‡åŒ–å¹¿åœº (3å·çº¿å´å±±å‰æ‘-æ˜Ÿæ¡¥, JSONåŸå·:0113)
            "330103_0501": "0315", // ç»¿æ±€è·¯ (3å·çº¿å´å±±å‰æ‘-æ˜Ÿæ¡¥, JSONåŸå·:0501)
            "330103_1902": "0312", // ç«è½¦è¥¿ç«™ (3å·çº¿å´å±±å‰æ‘-æ˜Ÿæ¡¥, JSONåŸå·:1902)
            "330104_0106": "0409", // è¿‘æ±Ÿ (4å·çº¿, JSONåŸå·:0106)
            "330104_0116": "0417", // ç«è½¦ä¸œç«™ (4å·çº¿, JSONåŸå·:0116)
            "330104_0117": "0418", // å½­åŸ  (4å·çº¿, JSONåŸå·:0117)
            "330104_0213": "0413", // é’±æ±Ÿè·¯ (4å·çº¿, JSONåŸå·:0213)
            "330104_0336": "0423", // æ–°å¤©åœ°è¡— (4å·çº¿, JSONåŸå·:0336)
            "330106_0105": "0632", // æ±Ÿé™µè·¯ (6å·çº¿æ¡‚èŠ±è¥¿è·¯-æ¸æ¡”å¼„, JSONåŸå·:0105)
            "330106_0403": "0626", // ä¸­åŒ»è¯å¤§å­¦ (6å·çº¿æ¡‚èŠ±è¥¿è·¯-æ¸æ¡”å¼„, JSONåŸå·:0403)
            "330107_0133": "0717", // è§å±±å›½é™…æœºåœº (7å·çº¿, JSONåŸå·:0133)
            "330107_0940": "0704", // è§‚éŸ³å¡˜ (7å·çº¿, JSONåŸå·:0940)
            "330109_0121": "0950", // å®¢è¿ä¸­å¿ƒ (9å·çº¿, JSONåŸå·:0121)
            "330110_0222": "1004", // å­¦é™¢è·¯ (10å·çº¿, JSONåŸå·:0222)
            "330118_0105": "0632", // æ±Ÿé™µè·¯ (6å·çº¿åŒæµ¦-æ¸æ¡”å¼„, JSONåŸå·:0105)
            "330118_0403": "0626", // ä¸­åŒ»è¯å¤§å­¦ (6å·çº¿åŒæµ¦-æ¸æ¡”å¼„, JSONåŸå·:0403)
            "330119_0112": "0330", // æ­¦æ—å¹¿åœº (3å·çº¿çŸ³é©¬-æ˜Ÿæ¡¥, JSONåŸå·:0112)
            "330119_0113": "0331", // è¥¿æ¹–æ–‡åŒ–å¹¿åœº (3å·çº¿çŸ³é©¬-æ˜Ÿæ¡¥, JSONåŸå·:0113)
            "330122_0501": "1612", // ç»¿æ±€è·¯ (16å·çº¿, JSONåŸå·:0501)
            "330123_0133": "1917", // è§å±±å›½é™…æœºåœº (19å·çº¿, JSONåŸå·:0133)
            "330123_0718": "1918", // æ°¸ç››è·¯ (19å·çº¿, JSONåŸå·:0718)
        };
        // ===================================================

        // è¾…åŠ©å‡½æ•°ï¼šè·å–ä¿®æ­£åçš„ ID
        function getFixedStationNo(lineNo, rawStationNo) {
            const key = `${lineNo}_${rawStationNo}`;
            // å¦‚æœè¡¨é‡Œæœ‰ä¿®æ­£å€¼ï¼Œå°±ç”¨ä¿®æ­£å€¼ï¼›å¦åˆ™ç”¨åŸå§‹å€¼
            return STATION_ID_FIX_MAP[key] || rawStationNo;
        }

        // ... ä½ çš„ SVG_URL ç­‰å…¶ä»–é…ç½® ...
        const SVG_URL = 'station_renamed_processed_merged_all_segmented_processed_renamed_by_geometry_plain.svg';

        // ================= å…¨å±€å˜é‡ =================
        let scheduleMap = {};
        let stationDependencyMap = {}; // æ–°å¢ï¼šå­˜å‚¨ { "station_ID": ["seg_ID_1", "seg_ID_2"...] }
        let stationRawData = {}; // ã€æ–°å¢ã€‘å­˜å‚¨äººç±»å¯è¯»çš„è½¦ç«™æ—¶åˆ»è¡¨ä¿¡æ¯ { "0101": Object }
        let activeSegmentsCache = new Set();
        let isLiveMode = true;
        let mapPanzoom;

        // ã€å…³é”®ä¿®å¤1ã€‘å°† UI å…ƒç´ æå‡ä¸ºå…¨å±€å˜é‡
        let slider, clock, liveToggle;
        let visualThumb; // æ–°å¢ï¼šè§†è§‰æŒ‡é’ˆ
        // ================= éçº¿æ€§æ»‘å—é…ç½® (çµæ•åº¦æ§åˆ¶) =================
        // å®šä¹‰ä¸€å¤©çš„èµ·å§‹æ—¶é—´: 04:00 (240åˆ†) åˆ° æ¬¡æ—¥ 04:00 (1680åˆ†)
        const START_MIN = 240;
        const END_MIN = 1680;

        // æ—¶é—´åˆ†æ®µç­–ç•¥ (æƒé‡ weight æ€»å’Œå¿…é¡»ä¸º 100)
        const TIME_SEGMENTS = [
            // 1. æ—©é—´å¯åŠ¨ (04:00 - 06:30): æƒé‡ 20%
            { endMinute: 390,  weight: 20 },
            // 2. ç™½å¤©å¹³å³° (06:30 - 21:30): æƒé‡ 15% (ä¸¥é‡å‹ç¼©ï¼Œå› ä¸ºä¸éœ€è¦ç»†çœ‹)
            { endMinute: 1290, weight: 15 },
            // 3. æ™šé—´åœè¿ (21:30 - 00:30): æƒé‡ 55% (ğŸŒŸæé«˜çµæ•åº¦ï¼Œæ‹‰é•¿æ˜¾ç¤º)
            { endMinute: 1470, weight: 55 },
            // 4. æ·±å¤œæ—¶æ®µ (00:30 - 04:00): æƒé‡ 10%
            { endMinute: 1680, weight: 10 }
        ];

        // ç®—æ³•ï¼šæ»‘å—ä½ç½® (0-10000) -> å®é™…åˆ†é’Ÿ
        function getMinutesFromSlider(sliderVal) {
            const percent = sliderVal / 10000 * 100;
            let accWeight = 0;
            let prevMin = START_MIN;

            for (const seg of TIME_SEGMENTS) {
                if (percent <= accWeight + seg.weight) {
                    const segPercent = (percent - accWeight) / seg.weight;
                    return Math.floor(prevMin + (seg.endMinute - prevMin) * segPercent);
                }
                accWeight += seg.weight;
                prevMin = seg.endMinute;
            }
            return END_MIN;
        }

        // ç®—æ³•ï¼šå®é™…åˆ†é’Ÿ -> æ»‘å—ä½ç½® (0-10000)
        function getSliderFromMinutes(minutes) {
            if (minutes < START_MIN) minutes += 1440; // è·¨æ—¥ä¿®æ­£
            if (minutes > END_MIN) minutes = END_MIN;

            let accWeight = 0;
            let prevMin = START_MIN;

            for (const seg of TIME_SEGMENTS) {
                if (minutes <= seg.endMinute) {
                    const segPercent = (minutes - prevMin) / (seg.endMinute - prevMin);
                    const totalPercent = accWeight + (segPercent * seg.weight);
                    return Math.floor(totalPercent / 100 * 10000);
                }
                accWeight += seg.weight;
                prevMin = seg.endMinute;
            }
            return 10000;
        }
        // ================= å·¥å…·å‡½æ•° =================
        function parseTime(timeStr) {
            if (!timeStr || typeof timeStr !== 'string') return null;
            const cleanStr = timeStr.trim();
            if (cleanStr === "") return null;
            const parts = cleanStr.split(':');
            if (parts.length < 2) return null;
            let h = parseInt(parts[0], 10);
            let m = parseInt(parts[1], 10);
            if (isNaN(h) || isNaN(m)) return null;
            if (h < 4) h += 24;
            return h * 60 + m;
        }

        function formatTime(minutes) {
            let h = Math.floor(minutes / 60);
            let m = Math.floor(minutes % 60);
            if (h >= 24) h -= 24;
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
        }

        // ================= åŠ è½½å™¨ =================
        async function loadSVG() {
            try {
                const response = await fetch(SVG_URL);
                if (!response.ok) throw new Error('SVG åŠ è½½å¤±è´¥');
                let svgText = await response.text();

                // æ¸…æ´— SVG
                svgText = svgText.replace(/<svg:svg/g, '<svg');
                svgText = svgText.replace(/<\/svg:svg>/g, '</svg>');
                svgText = svgText.replace(/width="[^"]*"/, 'width="100%"');
                svgText = svgText.replace(/height="[^"]*"/, 'height="100%"');

                const container = document.getElementById('map-container');
                container.innerHTML = svgText;

                // åˆå§‹åŒ– Panzoom
                const svgElement = container.querySelector('svg');
                if (svgElement) {
                    mapPanzoom = panzoom(svgElement, {
                        maxZoom: 50, minZoom: 0.1, initialZoom: 1,
                        bounds: true, boundsPadding: 0.1,
                        onTouch: function(e) { return false; } // å…è®¸é»˜è®¤æ‰‹åŠ¿
                    });
                    console.log("åœ°å›¾ç¼©æ”¾åŠŸèƒ½å·²å¯ç”¨");
                }
            } catch (e) {
                console.error(e);
                alert("åœ°å›¾ SVG åŠ è½½å¤±è´¥");
            }
        }

        async function loadAllData() {
            try {
                const response = await fetch('data/file_list.json');
                if (!response.ok) throw new Error('æ— æ³•è¯»å–æ–‡ä»¶åˆ—è¡¨ file_list.json');
                const fileList = await response.json();

                const promises = fileList.map(filename =>
                    fetch(`data/${filename}`).then(res => res.json())
                );
                const results = await Promise.all(promises);

                let allStations = [];
                results.forEach(data => {
                    if (data && data.result && data.result.station_list) {
                        allStations = allStations.concat(data.result.station_list);
                    }
                });
                return allStations;
            } catch (e) {
                console.error(e);
                return [];
            }
        }

        // ================= ç»ˆæç‰ˆ processData (åˆ©ç”¨ç«¯ç‚¹æ•°æ®) =================
        function processData(stationList) {
            const map = {};

            // 1. æ’åº
            stationList.sort((a, b) => {
                if (a.line_no !== b.line_no) return a.line_no - b.line_no;
                return a.up_ordinal - b.up_ordinal;
            });

            // è¾…åŠ©å‡½æ•° (ä¿æŒä¸å˜)
            function findValidId(prefix, id1, id2) {
                const candidate1 = `${prefix}_${id1}_${id2}`;
                const candidate2 = `${prefix}_${id2}_${id1}`;
                if (document.getElementById(candidate1)) return candidate1;
                if (document.getElementById(candidate2)) return candidate2;
                return null;
            }

            for (let i = 0; i < stationList.length - 1; i++) {
                const curr = stationList[i];
                const next = stationList[i + 1];

                // è·å–ä¿®æ­£åçš„ ID (ç”¨äº SVG æŸ¥æ‰¾)
                const currNo = (typeof getFixedStationNo === 'function') ?
                               getFixedStationNo(curr.line_no, curr.station_no) : curr.station_no;
                const nextNo = (typeof getFixedStationNo === 'function') ?
                               getFixedStationNo(next.line_no, next.station_no) : next.station_no;

                // å­˜å‚¨ RawData
                if (!stationRawData[currNo]) stationRawData[currNo] = { name: curr.station_name, line: curr.line_name, timetables: curr.first_last_weekdays };
                if (!stationRawData[nextNo]) stationRawData[nextNo] = { name: next.station_name, line: next.line_name, timetables: next.first_last_weekdays };

                if (curr.line_no !== next.line_no) continue;

                // ================= ä¸Šè¡Œå¤„ç† (Up): Curr -> Next =================
                let upStart = Infinity, upEnd = -Infinity, hasUp = false;
                // æ ‡è®° next æ˜¯å¦ä¸ºæŸç§åˆ—è½¦çš„ç»ˆç‚¹
                let isNextIsTerminal = false;

                if (curr.first_last_weekdays) {
                    curr.first_last_weekdays.forEach(plan => {
                        if (plan.up_first_time && plan.up_last_time) {
                            const s = parseTime(plan.up_first_time);
                            const e = parseTime(plan.up_last_time);
                            if (s !== null && e !== null) {
                                upStart = Math.min(upStart, s);
                                upEnd = Math.max(upEnd, e);
                                hasUp = true;

                                // ã€æ ¸å¿ƒä¿®æ”¹ã€‘æ£€æŸ¥æ•°æ®é‡Œçš„ç»ˆç‚¹ä¿¡æ¯
                                // æ³¨æ„ï¼šç”¨åŸå§‹ JSON çš„ station_no è¿›è¡Œæ¯”å¯¹
                                if (plan.up_end_station_no === next.station_no) {
                                    isNextIsTerminal = true;
                                }
                            }
                        }
                    });
                }

                if (hasUp && isFinite(upStart) && isFinite(upEnd)) {
                    const timeWindow = { start: upStart, end: upEnd };

                    // 1. ä¸»åŒºé—´ (Curr -> Next)
                    const mainId = findValidId('seg_up', currNo, nextNo);
                    if (mainId) map[mainId] = timeWindow;

                    // 2. å‡ºå‘ç«™è‡ªç¯ (Curr -> Curr)
                    // é€»è¾‘ï¼šåªè¦è½¦ä» Curr å‘å‡ºï¼ŒCurr ç«™å†…çš„ä¸Šè¡Œè½¨é“å°±æ˜¯äº®çš„
                    const startLoopId = `seg_up_${currNo}_${currNo}`;
                    if (document.getElementById(startLoopId)) {
                        map[startLoopId] = timeWindow;
                    }

                    // 3. ç»ˆç‚¹ç«™è‡ªç¯ (Next -> Next)
                    // é€»è¾‘ï¼šå¦‚æœ Next æ˜¯è¿™è¶Ÿè½¦çš„ç»ˆç‚¹ï¼ŒæŠŠ Next çš„è‡ªç¯ä¹Ÿç‚¹äº®
                    if (isNextIsTerminal) {
                        const endLoopId = `seg_up_${nextNo}_${nextNo}`;
                        if (document.getElementById(endLoopId)) {
                            map[endLoopId] = timeWindow;
                        }
                    }
                }

                // ================= ä¸‹è¡Œå¤„ç† (Down): Next -> Curr =================
                let downStart = Infinity, downEnd = -Infinity, hasDown = false;
                let isCurrIsTerminal = false;

                if (next.first_last_weekdays) {
                    next.first_last_weekdays.forEach(plan => {
                        if (plan.down_first_time && plan.down_last_time) {
                            const s = parseTime(plan.down_first_time);
                            const e = parseTime(plan.down_last_time);
                            if (s !== null && e !== null) {
                                downStart = Math.min(downStart, s);
                                downEnd = Math.max(downEnd, e);
                                hasDown = true;

                                // ã€æ ¸å¿ƒä¿®æ”¹ã€‘æ£€æŸ¥æ˜¯å¦åœ¨ Curr ç«™ç»ˆåˆ°
                                if (plan.down_end_station_no === curr.station_no) {
                                    isCurrIsTerminal = true;
                                }
                            }
                        }
                    });
                }

                if (hasDown && isFinite(downStart) && isFinite(downEnd)) {
                    const timeWindow = { start: downStart, end: downEnd };

                    // 1. ä¸»åŒºé—´ (Next -> Curr)
                    const mainId = findValidId('seg_down', nextNo, currNo);
                    if (mainId) map[mainId] = timeWindow;

                    // 2. å‡ºå‘ç«™è‡ªç¯ (Next -> Nextï¼Œå› ä¸ºä¸‹è¡Œæ˜¯ä» Next å‘è½¦)
                    const startLoopId = `seg_down_${nextNo}_${nextNo}`;
                    if (document.getElementById(startLoopId)) {
                        map[startLoopId] = timeWindow;
                    }

                    // 3. ç»ˆç‚¹ç«™è‡ªç¯ (Curr -> Curr)
                    if (isCurrIsTerminal) {
                        const endLoopId = `seg_down_${currNo}_${currNo}`;
                        if (document.getElementById(endLoopId)) {
                            map[endLoopId] = timeWindow;
                        }
                    }
                }
            }

            return map;
        }

        // ================= äº¤äº’é€»è¾‘ï¼šç‚¹å‡»æ˜¾ç¤ºä¿¡æ¯ =================

        const modal = document.getElementById('info-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');

        // å…³é—­å¼¹çª—
        window.closeModal = function() {
            modal.style.display = 'none';
        }

        // æ ¼å¼åŒ–åˆ†é’Ÿæ•°ä¸º HH:mm
        function minToTime(m) {
            if (!isFinite(m)) return "N/A";
            let h = Math.floor(m / 60);
            let min = Math.floor(m % 60);
            if (h >= 24) h -= 24;
            return `${h.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`;
        }

        // å¤„ç†åœ°å›¾ç‚¹å‡»
        function handleMapClick(e) {
            // 1. æ‰¾åˆ°è¢«ç‚¹å‡»çš„å…ƒç´  (å¤„ç† SVG å†’æ³¡)
            let target = e.target;

            // å¦‚æœç‚¹åˆ°äº† path å†…éƒ¨çš„æ–‡å­—æˆ–å…¶ä»–å­å…ƒç´ ï¼Œå‘å¤–æ‰¾ç›´åˆ°æ‰¾åˆ° ID
            while (target && target.tagName !== 'svg' && !target.id) {
                target = target.parentNode;
            }

            if (!target || !target.id) return;

            const id = target.id;

            // --- æƒ…å†µ A: ç‚¹å‡»äº†è½¦ç«™ (ID ä»¥ station_ å¼€å¤´) ---
            if (id.startsWith('station_')) {
                // æå–çº¯æ•°å­—ç¼–å· (ä¾‹å¦‚ station_0101_up -> 0101)
                // å‡è®¾ ID æ ¼å¼ä¸º station_XXXX æˆ– station_XXXX_up/down
                const match = id.match(/station_(\d+)/);
                if (!match) return;

                const stationNo = match[1];
                const data = stationRawData[stationNo];
                const dependencies = stationDependencyMap[id] || [];

                if (data) {
                    modalTitle.textContent = `${data.name} (${data.line})`;

                    let html = `
                                                <div class="info-block">
                            <span class="info-label">è½¦ç«™ ID:</span>
                            <span class="info-value">${id}</span>
                        </div>
                        <div class="info-block">
                        <span class="info-label">é¦–æœ«ç­è½¦æ—¶åˆ»:</span>`;

                    // éå†æ—¶åˆ»è¡¨æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
                    data.timetables.forEach(t => {
                        // ä¸Šè¡Œ
                        if (t.up_end_station_name) {
                            html += `<div>ä¸Šè¡ŒğŸŸ¢ å¾€ ${t.up_end_station_name}: ${t.up_first_time || '--'} / ${t.up_last_time || '--'}</div>`;
                        }
                        // ä¸‹è¡Œ
                        if (t.down_end_station_name) {
                            html += `<div>ä¸‹è¡ŒğŸ”µ å¾€ ${t.down_end_station_name}: ${t.down_first_time || '--'} / ${t.down_last_time || '--'}</div>`;
                        }
                    });

                    html += `</div>`;

                    // æ˜¾ç¤º Render ä¾èµ–ä¿¡æ¯
                    html += `<div class="info-block">
                        <span class="info-label">Render ä¾èµ– (è°ƒè¯•ç”¨):</span>
                        <div class="dep-list">`;

                    if (dependencies.length === 0) {
                        html += "æ— ä¾èµ– (å­¤å²›)";
                    } else {
                        dependencies.forEach(segId => {
                            const isActive = activeSegmentsCache.has(segId);
                            const statusIcon = isActive ? "âœ…" : "â¬›";
                            html += `<div>${statusIcon} ${segId}</div>`;
                        });
                    }
                    html += `</div></div>`;

                    modalContent.innerHTML = html;
                    modal.style.display = 'block';
                }
            }

            // --- æƒ…å†µ B: ç‚¹å‡»äº†çº¿è·¯ (ID ä»¥ seg_ å¼€å¤´) ---
            else if (id.startsWith('seg_')) {
                const windowData = scheduleMap[id];

                if (windowData) {
                    modalTitle.textContent = "åŒºé—´çº¿è·¯ä¿¡æ¯";

                    // è§£æ ID é‡Œçš„ç«™ç‚¹ç¼–å·æ¥çœ‹çœ‹æ˜¯å“ªå„¿åˆ°å“ªå„¿
                    // ID æ ¼å¼: seg_up_0101_0102
                    const parts = id.split('_');
                    const dir = parts[1] === 'up' ? 'ä¸Šè¡Œ' : 'ä¸‹è¡Œ';

                    let html = `
                        <div class="info-block">
                            <span class="info-label">åŒºé—´ ID:</span>
                            <span class="info-value">${id}</span>
                        </div>
                        <div class="info-block">
                            <span class="info-label">è¿è¥æ–¹å‘:</span>
                            <span class="info-value">${dir}</span>
                        </div>
                        <div class="info-block">
                            <span class="info-label">è®¡ç®—å‡ºçš„ç”Ÿæ•ˆçª—å£:</span>
                            <div class="info-value">
                                å¼€å§‹: ${minToTime(windowData.start)} (ç¬¬${windowData.start}åˆ†)<br>
                                ç»“æŸ: ${minToTime(windowData.end)} (ç¬¬${windowData.end}åˆ†)
                            </div>
                        </div>
                        <div class="info-block">
                            <span class="info-label">å½“å‰çŠ¶æ€:</span>
                            <span class="info-value">${activeSegmentsCache.has(id) ? 'ğŸŸ¢ è¿è¥ä¸­' : 'âš« å·²åœè¿'}</span>
                        </div>
                    `;

                    modalContent.innerHTML = html;
                    modal.style.display = 'block';
                }
            }
        }

        // ================= æ–°å¢ï¼šç”Ÿæˆç«™ç‚¹ä¸åŒºé—´çš„ä¾èµ–å…³ç³» =================
        function generateStationMap(stationList) {
            const dependencyMap = {};

            // è¾…åŠ©å‡½æ•°ï¼šæ‰¾ scheduleMap é‡ŒçœŸæ­£å­˜åœ¨çš„ ID (è§£å†³ 01_02 è¿˜æ˜¯ 02_01 çš„é—®é¢˜)
            function getActiveSegId(prefix, id1, id2) {
                // å…ˆçŒœæ­£å¸¸é¡ºåº
                const k1 = `${prefix}_${id1}_${id2}`;
                if (scheduleMap[k1]) return k1;
                // å†çŒœåå‘é¡ºåº
                const k2 = `${prefix}_${id2}_${id1}`;
                if (scheduleMap[k2]) return k2;
                return null;
            }

            // ç¡®ä¿åˆ—è¡¨æ’åº (Line -> UpOrdinal)
            stationList.sort((a, b) => {
                if (a.line_no !== b.line_no) return a.line_no - b.line_no;
                return a.up_ordinal - b.up_ordinal;
            });

            for (let i = 0; i < stationList.length; i++) {
                const curr = stationList[i];
                const prev = stationList[i - 1]; // ä¸Šä¸€ç«™
                const next = stationList[i + 1]; // ä¸‹ä¸€ç«™
                // ================== ã€ä¿®æ”¹ã€‘ ==================
                // è·å–ä¿®æ­£åçš„ç¼–å·
                const currNo = getFixedStationNo(curr.line_no, curr.station_no);
                const prevNo = (prev && prev.line_no === curr.line_no) ? getFixedStationNo(prev.line_no, prev.station_no) : null;
                const nextNo = (next && next.line_no === curr.line_no) ? getFixedStationNo(next.line_no, next.station_no) : null;
                // =============================================
                // 1. æ”¶é›†å½“å‰ç«™ç‚¹å¯èƒ½è¿æ¥çš„æ‰€æœ‰è½¨é“ ID
                const relatedSegments = {
                    upIn: null,   // ä¸Šè¡Œè¿›ç«™ (Prev -> Curr)
                    upOut: null,  // ä¸Šè¡Œå‡ºç«™ (Curr -> Next)
                    downIn: null, // ä¸‹è¡Œè¿›ç«™ (Next -> Curr)
                    downOut: null // ä¸‹è¡Œå‡ºç«™ (Curr -> Prev)
                };

                // ä½¿ç”¨ä¿®æ­£åçš„å˜é‡ (currNo, prevNo, nextNo)
                if (prevNo) {
                    relatedSegments.upIn = getActiveSegId('seg_up', prevNo, currNo);
                    relatedSegments.downOut = getActiveSegId('seg_down', currNo, prevNo);
                }

                if (nextNo) {
                    relatedSegments.upOut = getActiveSegId('seg_up', currNo, nextNo);
                    relatedSegments.downIn = getActiveSegId('seg_down', nextNo, currNo);
                }

                // ä½¿ç”¨ä¿®æ­£åçš„ currNo ç”Ÿæˆ DOM ID
                const stationIdBase = `station_${currNo}`;

                // æƒ…å†µ A: è¿™æ˜¯ä¸€ä¸ªåˆ†ä½“å¼ç«™ç‚¹ (æœ‰ _up å’Œ _down)
                const elUp = document.getElementById(`${stationIdBase}_up`);
                if (elUp) {
                    // ä¸Šè¡Œç«™å°ä¾èµ–ï¼šä¸Šè¡Œè¿› + ä¸Šè¡Œå‡º
                    dependencyMap[elUp.id] = [relatedSegments.upIn, relatedSegments.upOut].filter(id => id);
                }

                const elDown = document.getElementById(`${stationIdBase}_down`);
                if (elDown) {
                    // ä¸‹è¡Œç«™å°ä¾èµ–ï¼šä¸‹è¡Œè¿› + ä¸‹è¡Œå‡º
                    dependencyMap[elDown.id] = [relatedSegments.downIn, relatedSegments.downOut].filter(id => id);
                }

                // æƒ…å†µ B: è¿™æ˜¯ä¸€ä¸ªåˆä½“å¼ç«™ç‚¹ (åªæœ‰ station_0101)
                const elMain = document.getElementById(stationIdBase);
                if (elMain) {
                    // ä¸»ç«™å°ä¾èµ–ï¼šæ‰€æœ‰æ–¹å‘ (UpIn, UpOut, DownIn, DownOut)
                    dependencyMap[elMain.id] = [
                        relatedSegments.upIn, relatedSegments.upOut,
                        relatedSegments.downIn, relatedSegments.downOut
                    ].filter(id => id); // filter(id=>id) å»é™¤ nullï¼Œæ¯”å¦‚ç»ˆç‚¹ç«™æ²¡æœ‰å‡ºç«™è½¨é“
                }
            }

            return dependencyMap;
        }

        // ================= ä¿®æ”¹åçš„ render å‡½æ•° =================
        function render(currentTimeMinutes) {
            const newActiveSet = new Set();

            // --- 1. è®¡ç®—åŒºé—´çš„çŠ¶æ€ (å’Œä¹‹å‰ä¸€æ ·) ---
            for (const [id, window] of Object.entries(scheduleMap)) {
                if (currentTimeMinutes >= window.start && currentTimeMinutes <= window.end) {
                    newActiveSet.add(id);
                }
            }

            // --- 2. æ›´æ–°åŒºé—´ DOM (å’Œä¹‹å‰ä¸€æ ·) ---
            // å˜ç°
            activeSegmentsCache.forEach(id => {
                if (!newActiveSet.has(id)) {
                    const el = document.getElementById(id);
                    if (el) el.classList.add('disabled');
                }
            });
            // å˜äº®
            newActiveSet.forEach(id => {
                if (!activeSegmentsCache.has(id)) {
                    const el = document.getElementById(id);
                    if (el) el.classList.remove('disabled');
                }
            });
            activeSegmentsCache = newActiveSet; // æ›´æ–°ç¼“å­˜

            // --- 3. æ–°å¢ï¼šæ›´æ–°ç«™ç‚¹ (Station) çŠ¶æ€ ---
            // éå†æ‰€æœ‰åœ¨ SVG é‡Œæ‰¾åˆ°çš„ç«™ç‚¹
            for (const [stationId, segIds] of Object.entries(stationDependencyMap)) {
                const el = document.getElementById(stationId);
                if (!el) continue;

                // æ ¸å¿ƒé€»è¾‘ï¼šæ£€æŸ¥ä¾èµ–çš„è½¨é“é‡Œï¼Œæ˜¯å¦â€œè‡³å°‘æœ‰ä¸€æ¡â€æ˜¯æ´»è·ƒçš„
                // newActiveSet é‡Œå­˜çš„æ˜¯å½“å‰äº®ç€çš„è½¨é“ ID
                const isStationActive = segIds.some(segId => newActiveSet.has(segId));

                if (isStationActive) {
                    // åªè¦æœ‰ä¸€æ¡è·¯é€šï¼Œç«™ç‚¹å°±äº®
                    if (el.classList.contains('disabled')) {
                        el.classList.remove('disabled');
                    }
                } else {
                    // æ‰€æœ‰è·¯éƒ½ä¸é€š (Array.some è¿”å› false)ï¼Œç«™ç‚¹å˜ç°
                    if (!el.classList.contains('disabled')) {
                        el.classList.add('disabled');
                    }
                }
            }
        }

        function tick() {
            let minutes;
            // æ³¨æ„ï¼šè¿™é‡Œä¸å†ç”¨ 1560ï¼Œè€Œæ˜¯ç”¨æ»‘å—çš„æœ€å¤§ç²¾åº¦ 10000
            const SLIDER_MAX = 10000;

            if (isLiveMode) {
                // --- å®æ—¶æ¨¡å¼ ---
                const now = new Date();
                let h = now.getHours();
                const m = now.getMinutes();
                if (h < 4) h += 24;
                minutes = h * 60 + m;

                // 1. æ ¹æ®æ—¶é—´ -> ç®—å‡ºæ»‘å—åº”è¯¥åœ¨å“ª
                const sliderPos = getSliderFromMinutes(minutes);

                // 2. æ›´æ–°æ»‘å—å’Œçº¢çº¿
                if (slider) slider.value = sliderPos;
                if (visualThumb) visualThumb.style.left = `${sliderPos / SLIDER_MAX * 100}%`;

            } else {
                // --- æ‹–æ‹½æ¨¡å¼ ---
                // 1. è¯»å–æ»‘å—ä½ç½®
                const sliderVal = parseInt(slider.value, 10);

                // 2. æ ¹æ®æ»‘å—ä½ç½® -> ç®—å‡ºæ—¶é—´ (éçº¿æ€§)
                minutes = getMinutesFromSlider(sliderVal);

                // 3. æ›´æ–°çº¢çº¿ (ç›´æ¥ç”¨æ»‘å—ä½ç½®ç®—ç™¾åˆ†æ¯”ï¼Œä¿è¯ç»å¯¹è·Ÿæ‰‹)
                if (visualThumb) visualThumb.style.left = `${sliderVal / SLIDER_MAX * 100}%`;
            }

            // æ›´æ–°æ–‡å­—å’Œåœ°å›¾
            if (clock) clock.textContent = formatTime(minutes);
            render(minutes);

            // å¾ªç¯
            if (isLiveMode) {
                requestAnimationFrame(tick);
            }
        }

        // ================= åˆå§‹åŒ–å…¥å£ =================
        (async function initApp() {
            console.log("å¼€å§‹åŠ è½½èµ„æº...");

            // ã€å…³é”®ä¿®å¤2ã€‘åœ¨è¿™é‡Œè·å– DOM å…ƒç´ å¹¶èµ‹å€¼ç»™å…¨å±€å˜é‡
            slider = document.getElementById('time-slider');
            clock = document.getElementById('clock');
            liveToggle = document.getElementById('live-toggle');
            visualThumb = document.getElementById('custom-thumb'); // è·å–è§†è§‰æŒ‡é’ˆ

            const [_, allStations] = await Promise.all([
                loadSVG(),
                loadAllData()
            ]);

            console.log(`èµ„æºåŠ è½½å®Œæ¯•ï¼Œå…±è·å– ${allStations.length} ä¸ªç«™ç‚¹æ•°æ®`);
            const tip = document.getElementById('loading-tip');
            if (tip) tip.style.display = 'none';

            scheduleMap = processData(allStations);
            console.log("åŒºé—´æ—¶åˆ»è¡¨ç”Ÿæˆ:", scheduleMap);
            // ã€æ–°å¢ã€‘3. ç”Ÿæˆç«™ç‚¹ä¾èµ–è¡¨ (å¿…é¡»åœ¨ scheduleMap ç”Ÿæˆä¹‹å)
            stationDependencyMap = generateStationMap(allStations);
            console.log("ç«™ç‚¹ä¾èµ–å…³ç³»:", stationDependencyMap);

            // ã€å…³é”®ä¿®å¤3ã€‘åˆå§‹åŒ– Diff ç¼“å­˜
            // å‡è®¾ä¸€å¼€å§‹æ‰€æœ‰çº¿è·¯éƒ½æ˜¯äº®çš„ï¼Œå¡«æ»¡ç¼“å­˜ã€‚
            // è¿™æ ·å½“ç¬¬ä¸€å¸§ tick è¿è¡Œæ—¶ï¼Œå¦‚æœå½“å‰æ˜¯æ·±å¤œï¼ŒDiff ç®—æ³•ä¼šå‘ç° (All -> None)ï¼Œä»è€ŒæŠŠçº¿è·¯å˜ç°ã€‚
            activeSegmentsCache = new Set(Object.keys(scheduleMap));

            // åœ¨ initApp å‡½æ•°å†…éƒ¨ï¼Œç»‘å®šäº‹ä»¶ç›‘å¬çš„åœ°æ–¹ï¼š

            liveToggle.addEventListener('change', (e) => {
                isLiveMode = e.target.checked;

                if (isLiveMode) {
                    // ã€å…³é”®ã€‘å‹¾é€‰æ—¶ï¼Œç«‹å³è¸¢å®ƒä¸€è„šï¼Œè®©å®ƒå¼€å§‹è·‘
                    tick();

                    // å¯é€‰ï¼šç¦ç”¨æ»‘å—ï¼Œé˜²æ­¢ç”¨æˆ·åœ¨è‡ªåŠ¨è·‘çš„æ—¶å€™ä¹±æ‹–
                    slider.disabled = true;
                    // slider.style.opacity = '0.5'; // è§†è§‰å±‚å·²ç»æ¥ç®¡äº†ï¼Œslider æ˜¯é€æ˜çš„ï¼Œä¸ç”¨æ”¹é€æ˜åº¦
                } else {
                    // å–æ¶ˆå‹¾é€‰æ—¶ï¼Œæ¢å¤æ»‘å—æ§åˆ¶
                    slider.disabled = false;
                    // slider.style.opacity = '1';
                }
            });

            slider.addEventListener('input', () => {
                // 1. åªè¦ä¸€å¼€å§‹æ‹–åŠ¨ï¼Œç«‹åˆ»å–æ¶ˆå®æ—¶æ¨¡å¼
                if (isLiveMode) {
                    isLiveMode = false;
                    if (liveToggle) liveToggle.checked = false;
                    slider.disabled = false;
                }

                // 2. ç«‹å³æ›´æ–°è§†è§‰æŒ‡é’ˆ (ä¸ºäº†æå…¶è·Ÿæ‰‹)
                // ç›´æ¥ç”¨å½“å‰æ»‘å—çš„å€¼ (0-10000) ç®—ç™¾åˆ†æ¯”
                if (visualThumb) {
                    const val = parseInt(slider.value, 10);
                    const percent = val / 10000 * 100;
                    visualThumb.style.left = `${percent}%`;
                }

                // 3. è§¦å‘ä¸€æ¬¡ tick è®¡ç®—æ—¶é—´å¹¶æ¸²æŸ“åœ°å›¾
                tick();
            });

            // ã€æ–°å¢ã€‘ç»‘å®šåœ°å›¾ç‚¹å‡»äº‹ä»¶
            const mapContainer = document.getElementById('map-container');

            // ä½¿ç”¨ touchend å’Œ click å…¼å®¹å¤„ç†
            // ä¸ºé˜²æ­¢æ‹–æ‹½æ—¶è§¦å‘ clickï¼Œå¯ä»¥ç®€å•åˆ¤æ–­ä¸€ä¸‹
            let isDragging = false;
            mapContainer.addEventListener('mousedown', () => isDragging = false);
            mapContainer.addEventListener('mousemove', () => isDragging = true);

            mapContainer.addEventListener('click', (e) => {
                // å¦‚æœ panzoom æ­£åœ¨è¢«æ‹–åŠ¨ï¼Œå°±ä¸è§¦å‘ç‚¹å‡»
                // æ³¨æ„ï¼španzoom çš„ dragging çŠ¶æ€åˆ¤æ–­æ¯”è¾ƒå¾®å¦™ï¼Œè¿™é‡Œç”¨ç®€å•çš„ mousemove åˆ¤å®š
                // å¦‚æœéœ€è¦æ›´ç²¾ç¡®ï¼Œå¯ä»¥åˆ¤æ–­ mousedown å’Œ mouseup çš„åæ ‡å·®
                if (isDragging) return;
                handleMapClick(e);
            });
            // ...
            tick();
        })();
    </script>
</body>
</html>